{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to my personal knowledge base \u2014 a curated collection of notes, explanations, and resources I\u2019ve written while learning and revising various technical topics.</p> <p>This site is built with MkDocs Material and serves as both a reference and a learning log \u2014 a place where I organize thoughts, code snippets, and insights gathered over time.</p> <p>To run this site locally: </p><pre><code>pip install -r requirements.txt\nmkdocs serve\n</code></pre><p></p>"},{"location":"DSA/","title":"DSA","text":""},{"location":"DSA/#dsa","title":"DSA","text":"<ul> <li> Neetcode 150</li> </ul>"},{"location":"DSA/neetcode150/","title":"Neetcode 150","text":""},{"location":"DSA/neetcode150/#neetcode-150","title":"Neetcode 150","text":"<p>Explanation and solutions to list of Leetcode problems created by Neetcode. It consists of 150 DSA problems, categorized into patterns derived from the blind 75 list. People already familiar with basic algorithms &amp; data structures can use this list for a quick review for technical interviews.</p>"},{"location":"DSA/neetcode150/Arrays_and_Hashing/","title":"Index","text":""},{"location":"DSA/neetcode150/Arrays_and_Hashing/contains_duplicate/","title":"\ud83d\udfe2 217. Contains Duplicate","text":"","tags":["Hash Table","Array","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/contains_duplicate/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<p>Problem Link</p> <p>Brute Force: You can iterate twice over the Array to check if element from outer iteration is present using inner  iteration. This would yield following runtime complexity: Time -&gt; \\(O(n^2)\\), Space -&gt; \\(O(1)\\)</p> <p>We can optimize the operation of checking if an element is present from \\(O(n)\\) to \\(O(1)\\) using a data structure like  HashSet which gives us constant time querying operation. The tradeoff being increase in space complexity to \\(O(n)\\), which majority of time is acceptable as memory isn't as scare as old days.</p> Pseudocode <ul> <li>Iterate over the \\(nums\\) array. For each \\(num\\),</li> <li>check if the \\(num\\) is present in our hashset. <ul> <li>If yes, we can return immediately</li> <li>Else, store current \\(num\\) in our hashset and continue. </li> </ul> </li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), since we're only iterating the nums array once and querying hashset, an \\(O(1)\\) operation.</p> <p>Space: \\(O(n)\\), due to the hashset used for storing num.</p> PythonGo <pre><code>class Solution:\n    def containsDuplicate(self, nums: List[int]) -&gt; bool:\n        visited = set()\n        for num in nums:\n            if num in visited:\n                return True\n            visited.add(num)\n        return False\n</code></pre> <pre><code>func containsDuplicate(nums []int) bool {\n    set := make(map[int]interface{})\n    for _, num := range nums {\n        _, ok := set[num]\n        if ok {\n            return true\n        }\n        set[num] = nil\n    }\n    return false\n}\n</code></pre>","tags":["Hash Table","Array","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/encode_and_decode_strings/","title":"\ud83d\udfe0 271. Encode and Decode Strings","text":"","tags":["Hash Table","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/encode_and_decode_strings/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<p>Problem Link</p> <p>One of the most common pattern for encoding any data structure into stream of continuous data type is to use the size of data structure to denote the amount of data to read from stream for parsing single unit of data. But, since our data might also include numbers there would be no way to differentiate the size data from data structure value. To solve this, you can simply use a placeholder value between two of these values. This would lead us to create streams as follows -&gt; <code>&lt;size&gt;&lt;placeholder&gt;&lt;data&gt;...</code></p> Pseudocode <p>Encode: Since our data structure is simply list of strings, we can</p> <ul> <li>Calculate the size of each string</li> <li>Generate the encoded token for this string -&gt; <code>&lt;size&gt;&lt;placeholder&gt;&lt;string&gt;</code></li> <li>Join all the token strings to get encoded data.</li> </ul> <p>Decode: You can use two pointers to indicate the start and current position in stream.</p> <ul> <li>We need to parse the stream until we reach end of it</li> <li>Start by parsing the size of next data token, by reading data until you encounter the placeholder value.</li> <li>Next decode the size into a number and read next <code>size</code> amount of data (skipping the placeholder).</li> <li>Update the start and current pointer to end of current token and continue.</li> </ul> Runtime Complexity <p>Time: \\(O(n)\\) &lt;- encode, \\(O(n)\\) &lt;- decode</p> <p>Space: \\(O(n)\\) &lt;- encode (from storing tokens/output), \\(O(n)\\) &lt;- decode </p> PythonGo <pre><code>class Solution:\n    DELIMITER = \"#\"\n    def encode(self, strs: List[str]) -&gt; str:\n        tokens = []\n        for s in strs:\n            token = f\"{len(s)}{self.DELIMITER}{s}\"\n            tokens.append(token)\n\n        return \"\".join(tokens)\n\n    def decode(self, s: str) -&gt; List[str]:\n        start = curr = 0\n        strs = []\n        while curr &lt; len(s):\n            while s[curr] != self.DELIMITER:\n                curr+=1\n\n            size = int(s[start:curr])\n            strs.append(s[curr+1: curr+size+1])\n            start = curr+size+1\n            curr = curr+size+1\n\n        return strs\n</code></pre> <pre><code>type Solution struct{}\n\nfunc (s *Solution) Encode(strs []string) string {\n    var tokens []string\n    for _, str := range strs {\n        tokens = append(tokens, fmt.Sprintf(\"%d#%s\", len(str), str))\n    }\n    return strings.Join(tokens, \"\")\n}\n\nfunc (s *Solution) Decode(str string) []string {\n    var strs []string\n    var start, curr int\n    for curr &lt; utf8.RuneCountInString(str) {\n        for str[curr] != '#' {\n            curr++\n        }\n        size, _ := strconv.Atoi(str[start:curr])\n        strs = append(strs, str[curr+1:curr+1+size])\n        start = curr + 1 + size\n        curr = start\n    }\n    return strs\n}\n</code></pre>","tags":["Hash Table","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/group_anagrams/","title":"\ud83d\udfe0 49. Group Anagrams","text":"","tags":["Hash Table","Array","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/group_anagrams/#49-group-anagrams","title":"49. Group Anagrams","text":"<p>Problem Link</p> <p>You can check this problem on how to find if two strings are anagrams.</p> <p>If we map a string into an Array of size 26, where each element represents the occurrence a character in a string. The associated character at any index in the Array is found by adding the ASCII code of 'a' to the index -&gt; \\(index+ascii(a)\\). And we're using size 26, because the string only have lowercase english characters which can be mapped to 26 positions in our array.</p> <p>You can think of the generated Array as a kind of bitmap and strings which are anagram would've same bitmap.  We can use this information to generate the group of Anagram string. </p> Pseudocode <ul> <li>Iterate over each string. During each iteration, </li> <li>Generate the bitmap of the string.</li> <li>Store the string in a Hashmap where key is bitmap and value is list of string with same bitmap.</li> <li>Finally returns the values of Hashmap, which would be grouped Anagram strings.</li> </ul> Runtime Complexity <p><code>strs</code> -&gt; length \\(n\\), with string of maximum size \\(k\\). </p> <p>Time: \\(O(nk)\\) &lt;- \\(O(n)\\) from iterating <code>strs</code>, \\(O(k)\\) for generating bitmap of each string.</p> <p>Space: \\(O(n)\\) &lt;- from Hashmap for storing the groups.</p> PythonGo <pre><code>class Solution:\n    def _get_bitmap(self, s: str) -&gt; tuple:\n        l = [0] * 26\n        for ch in s:\n            l[ord(ch) - ord('a')] += 1\n        return tuple(l)\n\n    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:\n        freq = {}  # bitmap -&gt; str\n\n        for s in strs:\n            bitmap = self._get_bitmap(s)\n            if bitmap in freq:\n                freq[bitmap].append(s)\n            else:\n                freq[bitmap] = [s]\n        return list(freq.values())\n</code></pre> <pre><code>func getBitmap(s string) [26]int {\n    var bitmap [26]int\n    for _, ch := range s {\n        bitmap[ch-'a']++\n    }\n    return bitmap\n}\n\nfunc groupAnagrams(strs []string) [][]string {\n    freq := make(map[[26]int][]string)\n    for _, str := range strs {\n        bitmap := getBitmap(str)\n        freq[bitmap] = append(freq[bitmap], str)\n    }\n\n    var groups [][]string\n    for _, group := range freq {\n        groups = append(groups, group)\n    }\n    return groups\n}\n</code></pre> Implementation Note <p>Python: We're using tuple as key, because they're hashable object. If you use strings as key, consider the number of digits in counts when generating the string key.</p> <p>Go: keys to map must be <code>comparable</code> types. Slices (<code>[]int</code>) aren't comparablable but Arrays (<code>[N]T</code>) are comparable if their element Type (<code>T</code>) is comparable. </p>","tags":["Hash Table","Array","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/longest_consecutive_sequence/","title":"\ud83d\udfe0 128. Longest Consecutive Sequence","text":"","tags":["Array","Hash Table","Union Find","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/longest_consecutive_sequence/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<p>Problem Link</p> <p>Brute Force: Since we only need to find the longest consecutive sequence irrespective of order in array, we can check the sequence starting each element and take the longest. This would result in \\(O(n^2)\\) time  complexity.</p> <p>To optimize this, we can just check the sequence for \\(num_i\\) whose previous number (\\(num_i-1\\)) isn't present in our  array, as these number are guaranteed to generate unique sequence . This would result in checking the sequence for elements only once. </p> Pseudocode <ul> <li>Iterate over the nums array. To keep checks constant time, we can also create a Hashset out of <code>nums</code> array.</li> <li>For each <code>num</code>, if the previous (<code>num-1</code>) isn't present in our array means we've a unique sequence starting    from this <code>num</code>.</li> <li>To generate this sequence, declare a length pointer and increment it until we exhaust the sequence numbers   present in our hashset.</li> <li>Finally use a global variable to maintain the maximum length.</li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), single iteration over each element with constant time checks. It might look like we're iterating within 2 loops, but the conditional will reduce the inner iteration such that we're not repeating checks.</p> <p>Space: \\(O(n)\\) &lt;- from hashmap.</p> PythonGo <pre><code>class Solution:\n    def longestConsecutive(self, nums: List[int]) -&gt; int:\n        res = 0\n        nums = set(nums)\n        for num in nums:\n            if num-1 not in nums:\n                length = 1\n                while num+length in nums:\n                    length+=1\n                res = max(length, res)\n        return res\n</code></pre> <pre><code>func longestConsecutive(nums []int) int {\n    set := make(map[int]interface{})\n    for _, num := range nums {\n        set[num] = nil\n    }\n    res := 0\n    for num, _ := range set {\n        if _, ok := set[num-1]; !ok {\n            length := 1\n            for {\n                if _, ok := set[num+length]; ok {\n                    length++\n                } else {\n                    break\n                }\n            }\n            res = max(res, length)\n        }\n    }\n    return res\n}\n</code></pre>","tags":["Array","Hash Table","Union Find","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/product_of_array_except_self/","title":"\ud83d\udfe0 238. Product of Array Except Self","text":"","tags":["Array","Prefix Sum","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/product_of_array_except_self/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<p>Problem Link</p> <p>The catch of problem is we can't use division operator. If that wasn't the case, we could simply have aggregated multiplication of whole array and divide each element by it get their own product without self.</p> <p>When translated to equations, this would look like: \\(\\prod_{i=1}^{n} nums_i \\over nums_i\\). By removing the division  -&gt; \\(\\prod_{i=1}^{i-1} nums_i * \\prod_{i=i+1}^{n} nums_i\\), which is basically product of prefix and postfix array to index <code>i</code>.</p> <p>One way to implement this is to store prefix and postfix multiplication in two separate arrays and combine them to generate the result. </p> <p>Follow Up</p> <p>Instead of saving the prefix and postfix multiplication within separate array, we can simply store them within output array (since multiplication is communicative) </p> Pseudocode <ul> <li>To generate prefix, iterate from start of <code>nums</code> and using a variable to aggregate the multiplication over   the iteration.</li> <li>To generate postfix, iterate from end of <code>nums</code> and repeat same.</li> </ul> Runtime Complexity <p>Time: \\(O(n)\\)</p> <p>Space: \\(O(1)\\) &lt;- output isn't considered</p> PythonGo <pre><code>class Solution:\n    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:\n        result = []\n        pre, post = 1, 1\n\n        for i in range(len(nums)):\n            result.append(pre)\n            pre *= nums[i]\n\n        for i in reversed(range(len(nums))):\n            result[i] *= post\n            post *= nums[i]\n        print(result)\n        return result\n</code></pre> <pre><code>func productExceptSelf(nums []int) []int {\n    result := make([]int, len(nums))\n    var pre, post int = 1, 1\n    for idx := range nums {\n        result[idx] = pre\n        pre *= nums[idx]\n    }\n\n    for idx := len(nums) - 1; idx &gt;= 0; idx-- {\n        result[idx] *= post\n        post *= nums[idx]\n    }\n    return result\n}\n</code></pre>","tags":["Array","Prefix Sum","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/top_k_frequent_element/","title":"\ud83d\udfe0 347. Top K Frequent Elements","text":"","tags":["Hash Table","Array","Heap/Priority Queue","LC_Medium","Neetcode150","Bucket Sort"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/top_k_frequent_element/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<p>Problem Link</p> <p>Heap</p> <p>This is a general problem designed to be solved efficiently using heap data structure. For now, we'll solve it using hashmaps.</p> <p>The general idea to solve this is by generating a hashmap where the value is list of numbers and key is the frequency of those number in <code>nums</code>. Now, you can use this hashmap to generate list of nums sorted in order of their frequency in <code>nums</code>. But for this problem, we only want first \\(k\\) elements from this list.</p> Pseudocode <ul> <li>Generate hashmap where key is \\(num\\) and value is frequency of that \\(num\\) in <code>nums</code>.</li> <li>Using above hashmap, generate another hashmap where key is a number and value is the list   of numbers having \\(key\\) frequency in <code>nums</code>.</li> <li>Generate result having numbers sorted in order of highest frequency.    Since the highest frequency could be <code>len(nums)</code> while smallest -&gt; \\(0\\).<ul> <li>Iterate from the highest frequency to the smallest while adding numbers of   frequencies found in our hashmap. </li> </ul> </li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), from iterating <code>nums</code>.</p> <p>Space: \\(O(n)\\) &lt;- from hashmaps.</p> PythonGo <pre><code>class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        freq = Counter(nums)\n        buckets = defaultdict(list)\n        for num, count in freq.items():\n            buckets[count].append(num)\n\n        result = []\n        for count in range(len(nums), 0, -1):\n            if count in buckets:\n                result.extend(buckets[count])\n\n        return result[:k]\n</code></pre> <pre><code>func topKFrequent(nums []int, k int) []int {\n    freq := make(map[int]int)\n    for _, num := range nums {\n        freq[num]++\n    }\n    buckets := make(map[int][]int)\n    for num, count := range freq {\n        buckets[count] = append(buckets[count], num)\n    }\n\n    var result []int\n    for i := len(nums); i &gt;= 0; i-- {\n        vals, ok := buckets[i]\n        if ok {\n            result = append(result, vals...)\n        }\n    }\n    return result[:k]\n}\n</code></pre>","tags":["Hash Table","Array","Heap/Priority Queue","LC_Medium","Neetcode150","Bucket Sort"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/two_sum/","title":"\ud83d\udfe2 1. Two Sum","text":"","tags":["Hash Table","Array","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/two_sum/#1-two-sum","title":"1. Two Sum","text":"<p>Problem Link</p> <p>You can think of the problem as,  given a number \\(num\\) find the index of \\(target-num\\).</p> <p>This can be done by storing the index of each \\(num\\) in a data structure like Hashmap which can be queried to fetch index of a value in a constant time.</p> Pseudocode <ul> <li>Iterate over the \\(nums\\) array. For each \\(num\\),</li> <li>check if the \\(target-num\\) is present in our map.<ul> <li>If yes, we can directly return the current index and saved index from here</li> <li>Else, store the index of current num in our map and continue. </li> </ul> </li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), since we're only iterating the nums array once and querying hashmap is an \\(O(1)\\) operation.</p> <p>Space: \\(O(n)\\), due to the map used for storing num -&gt; index mapping</p> PythonGo <pre><code>class Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        s = dict()\n        for i, num in enumerate(nums):\n            if num in s:\n                return [i, s[num]]\n            s[target - num] = i\n        return [-1, -1]\n</code></pre> <pre><code>func twoSum(nums []int, target int) []int {\n    idxMap := make(map[int]int)\n    for idx, num := range nums {\n        if val, ok := idxMap[num]; ok {\n            return []int{val, idx}\n        }\n        idxMap[target-num] = idx\n    }\n    return []int{}\n}\n</code></pre>","tags":["Hash Table","Array","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/valid_anagram/","title":"\ud83d\udfe2 242. Valid Anagram","text":"","tags":["Hash Table","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/valid_anagram/#242-valid-anagram","title":"242. Valid Anagram","text":"<p>Problem Link</p> <p>Given strings <code>s</code> and <code>t</code>, they're Anagram if we can rearrange the characters of one to form another. This can be reworded as, both strings should have same characters. We can check this by storing the frequency of one string and match them with the other.  </p> Pseudocode <ul> <li>If strings have different number of characters, we can return early as they'll never have same characters.</li> <li>Otherwise, we'll iterate over one string and store the frequency of each character in a hashmap.</li> <li>Iterate over other string to reduce the frequency of encountered character.</li> <li>During which, we can say the strings aren\u2019t anagrams if we encounter any character which either isn't present              in our hashmap, or the frequency of character is exhausted.</li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), since we're only iterating the strings twice, with insertion and querying hashmap being \\(O(1)\\)             operation.</p> <p>Space: \\(O(n)\\), due to the hashmap used for storing characters frequency.</p> PythonGo <pre><code>class Solution:\n    def isAnagram(self, s: str, t: str) -&gt; bool:\n        if len(s) != len(t):\n            return False\n\n        freq = dict()\n        for i in s:\n            freq[i] = freq.get(i, 0) + 1\n\n        for i in t:\n            if i not in freq or freq[i] == 0:\n                return False\n\n            freq[i] -= 1\n\n        return True\n</code></pre> <pre><code>func isAnagram(s string, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    freq := make(map[rune]int)\n    for _, ch := range s {\n        freq[ch]++\n    }\n\n    for _, ch := range t {\n        val, ok := freq[ch]\n        if !ok || val == 0 {\n            return false\n        }\n        freq[ch]--\n    }\n    return true\n}\n</code></pre>","tags":["Hash Table","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/valid_sudoku/","title":"\ud83d\udfe0 36. Valid Sudoku","text":"","tags":["Array","Hash Table","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/valid_sudoku/#36-valid-sudoku","title":"36. Valid Sudoku","text":"<p>Problem Link</p> <p>To check if a sudo board is valid, you've to satisfy 3 types of criteria: - each row shouldn't have repeating digit. - each column shouldn't have repeating digit. - each box (3x3 here) shouldn't have a repeating digit.</p> <p>This can be checked pretty easily using hash maps (similar to contains_dupliacte).</p> How would you map cells within a box to same key? <p>\\(key=(floor(row/3))*3 + (floor(col/3))\\)</p> Pseudocode <ul> <li>Iterate over the board using two loops. Within each iteration, if the cell isn't <code>.</code></li> <li>check if the value is present in your hashmap buckets.<ul> <li>if present, we can say the sudoku is invalid and return.</li> <li>else add the values to respective hashmap key.</li> </ul> </li> </ul> Runtime Complexity <p>number of elements in board -&gt; n</p> <p>Time: \\(O(n)\\), single iteration over each element with constant time checks.</p> <p>Space: \\(O(n)\\) &lt;- from hashmaps.</p> PythonGo <pre><code>class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:\n        rows = defaultdict(set)\n        cols = defaultdict(set)\n        box = defaultdict(set)\n        for r in range(len(board)):\n            for c in range(len(board[0])):\n                cell = board[r][c]\n                b = (r // 3) * 3 + c // 3\n                if cell == \".\":\n                    continue\n                elif cell in rows[r] or cell in cols[c] or cell in box[b]:\n                    return False\n\n                rows[r].add(cell)\n                cols[c].add(cell)\n                box[b].add(cell)\n        return True\n</code></pre> <pre><code>func isValidSudoku(board [][]byte) bool {\n    var rows, cols, boxes [9][9]bool\n\n    for r := range board {\n        for c := range board[0] {\n            cell := board[r][c]\n            if cell != '.' {\n                b := (r/3)*3 + (c / 3)\n                idx := int(cell - '1')\n                if rows[r][idx] || cols[c][idx] || boxes[b][idx] {\n                    return false\n                }\n                rows[r][idx] = true\n                cols[c][idx] = true\n                boxes[b][idx] = true\n            }\n        }\n    }\n    return true\n}\n</code></pre>","tags":["Array","Hash Table","LC_Medium","Neetcode150"]}]}