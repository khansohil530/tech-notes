{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Welcome to my personal knowledge base \u2014 a curated collection of notes, explanations, and resources I\u2019ve written while learning and revising various technical topics.</p> <p>This site is built with MkDocs Material and serves as both a reference and a learning log \u2014 a place where I organize thoughts, code snippets, and insights gathered over time.</p> <p>To run this site locally: </p><pre><code>pip install -r requirements.txt\nmkdocs serve\n</code></pre><p></p>"},{"location":"DSA/","title":"DSA","text":""},{"location":"DSA/#dsa","title":"DSA","text":"<ul> <li> Neetcode 150</li> </ul>"},{"location":"DSA/neetcode150/","title":"Neetcode 150","text":""},{"location":"DSA/neetcode150/#neetcode-150","title":"Neetcode 150","text":"<p>Explanation and solutions to list of Leetcode problems created by Neetcode. It consists of 150 DSA problems, categorized into patterns derived from the blind 75 list. People already familiar with basic algorithms &amp; data structures can use this list for a quick review for technical interviews.</p>"},{"location":"DSA/neetcode150/Arrays_and_Hashing/contains_duplicate/","title":"\ud83d\udfe2 217. Contains Duplicate","text":"","tags":["Hash Table","Array","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/contains_duplicate/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<p>Problem Link</p> <p>Brute Force: You can iterate twice over the Array to check if element from outer iteration is present using inner  iteration. This would yield following runtime complexity: Time -&gt; \\(O(n^2)\\), Space -&gt; \\(O(1)\\)</p> <p>We can optimize the operation of checking if an element is present from \\(O(n)\\) to \\(O(1)\\) using a data structure like  HashSet which gives us constant time querying operation. The tradeoff being increase in space complexity to \\(O(n)\\), which majority of time is acceptable as memory isn't as scare as old days.</p> Pseudocode <ul> <li>Iterate over the \\(nums\\) array. For each \\(num\\),</li> <li>check if the \\(num\\) is present in our hashset. <ul> <li>If yes, we can return immediately</li> <li>Else, store current \\(num\\) in our hashset and continue. </li> </ul> </li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), since we're only iterating the nums array once and querying hashset, an \\(O(1)\\) operation.</p> <p>Space: \\(O(n)\\), due to the hashset used for storing num.</p> PythonGo <pre><code>class Solution:\n    def containsDuplicate(self, nums: List[int]) -&gt; bool:\n        visited = set()\n        for num in nums:\n            if num in visited:\n                return True\n            visited.add(num)\n        return False\n</code></pre> <pre><code>func containsDuplicate(nums []int) bool {\n    set := make(map[int]interface{})\n    for _, num := range nums {\n        _, ok := set[num]\n        if ok {\n            return true\n        }\n        set[num] = nil\n    }\n    return false\n}\n</code></pre>","tags":["Hash Table","Array","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/encode_and_decode_strings/","title":"\ud83d\udfe0 271. Encode and Decode Strings","text":"","tags":["Hash Table","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/encode_and_decode_strings/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<p>Problem Link</p> <p>One of the most common pattern for encoding any data structure into stream of continuous data type is to use the size of data structure to denote the amount of data to read from stream for parsing single unit of data. But, since our data might also include numbers there would be no way to differentiate the size data from data structure value. To solve this, you can simply use a placeholder value between two of these values. This would lead us to create streams as follows -&gt; <code>&lt;size&gt;&lt;placeholder&gt;&lt;data&gt;...</code></p> Pseudocode <p>Encode: Since our data structure is simply list of strings, we can</p> <ul> <li>Calculate the size of each string</li> <li>Generate the encoded token for this string -&gt; <code>&lt;size&gt;&lt;placeholder&gt;&lt;string&gt;</code></li> <li>Join all the token strings to get encoded data.</li> </ul> <p>Decode: You can use two pointers to indicate the start and current position in stream.</p> <ul> <li>We need to parse the stream until we reach end of it</li> <li>Start by parsing the size of next data token, by reading data until you encounter the placeholder value.</li> <li>Next decode the size into a number and read next <code>size</code> amount of data (skipping the placeholder).</li> <li>Update the start and current pointer to end of current token and continue.</li> </ul> Runtime Complexity <p>Time: \\(O(n)\\) &lt;- encode, \\(O(n)\\) &lt;- decode</p> <p>Space: \\(O(n)\\) &lt;- encode (from storing tokens/output), \\(O(n)\\) &lt;- decode </p> PythonGo <pre><code>class Solution:\n    DELIMITER = \"#\"\n    def encode(self, strs: List[str]) -&gt; str:\n        tokens = []\n        for s in strs:\n            token = f\"{len(s)}{self.DELIMITER}{s}\"\n            tokens.append(token)\n\n        return \"\".join(tokens)\n\n    def decode(self, s: str) -&gt; List[str]:\n        start = curr = 0\n        strs = []\n        while curr &lt; len(s):\n            while s[curr] != self.DELIMITER:\n                curr+=1\n\n            size = int(s[start:curr])\n            strs.append(s[curr+1: curr+size+1])\n            start = curr+size+1\n            curr = curr+size+1\n\n        return strs\n</code></pre> <pre><code>type Solution struct{}\n\nfunc (s *Solution) Encode(strs []string) string {\n    var tokens []string\n    for _, str := range strs {\n        tokens = append(tokens, fmt.Sprintf(\"%d#%s\", len(str), str))\n    }\n    return strings.Join(tokens, \"\")\n}\n\nfunc (s *Solution) Decode(str string) []string {\n    var strs []string\n    var start, curr int\n    for curr &lt; utf8.RuneCountInString(str) {\n        for str[curr] != '#' {\n            curr++\n        }\n        size, _ := strconv.Atoi(str[start:curr])\n        strs = append(strs, str[curr+1:curr+1+size])\n        start = curr + 1 + size\n        curr = start\n    }\n    return strs\n}\n</code></pre>","tags":["Hash Table","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/group_anagrams/","title":"\ud83d\udfe0 49. Group Anagrams","text":"","tags":["Hash Table","Array","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/group_anagrams/#49-group-anagrams","title":"49. Group Anagrams","text":"<p>Problem Link</p> <p>You can check this problem on how to find if two strings are anagrams.</p> <p>If we map a string into an Array of size 26, where each element represents the occurrence a character in a string. The associated character at any index in the Array is found by adding the ASCII code of 'a' to the index -&gt; \\(index+ascii(a)\\). And we're using size 26, because the string only have lowercase english characters which can be mapped to 26 positions in our array.</p> <p>You can think of the generated Array as a kind of bitmap and strings which are anagram would've same bitmap.  We can use this information to generate the group of Anagram string. </p> Pseudocode <ul> <li>Iterate over each string. During each iteration, </li> <li>Generate the bitmap of the string.</li> <li>Store the string in a Hashmap where key is bitmap and value is list of string with same bitmap.</li> <li>Finally returns the values of Hashmap, which would be grouped Anagram strings.</li> </ul> Runtime Complexity <p><code>strs</code> -&gt; length \\(n\\), with string of maximum size \\(k\\). </p> <p>Time: \\(O(nk)\\) &lt;- \\(O(n)\\) from iterating <code>strs</code>, \\(O(k)\\) for generating bitmap of each string.</p> <p>Space: \\(O(n)\\) &lt;- from Hashmap for storing the groups.</p> PythonGo <pre><code>class Solution:\n    def _get_bitmap(self, s: str) -&gt; tuple:\n        l = [0] * 26\n        for ch in s:\n            l[ord(ch) - ord('a')] += 1\n        return tuple(l)\n\n    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:\n        freq = {}  # bitmap -&gt; str\n\n        for s in strs:\n            bitmap = self._get_bitmap(s)\n            if bitmap in freq:\n                freq[bitmap].append(s)\n            else:\n                freq[bitmap] = [s]\n        return list(freq.values())\n</code></pre> <pre><code>func getBitmap(s string) [26]int {\n    var bitmap [26]int\n    for _, ch := range s {\n        bitmap[ch-'a']++\n    }\n    return bitmap\n}\n\nfunc groupAnagrams(strs []string) [][]string {\n    freq := make(map[[26]int][]string)\n    for _, str := range strs {\n        bitmap := getBitmap(str)\n        freq[bitmap] = append(freq[bitmap], str)\n    }\n\n    var groups [][]string\n    for _, group := range freq {\n        groups = append(groups, group)\n    }\n    return groups\n}\n</code></pre> Implementation Note <p>Python: We're using tuple as key, because they're hashable object. If you use strings as key, consider the number of digits in counts when generating the string key.</p> <p>Go: keys to map must be <code>comparable</code> types. Slices (<code>[]int</code>) aren't comparablable but Arrays (<code>[N]T</code>) are comparable if their element Type (<code>T</code>) is comparable. </p>","tags":["Hash Table","Array","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/longest_consecutive_sequence/","title":"\ud83d\udfe0 128. Longest Consecutive Sequence","text":"","tags":["Array","Hash Table","Union Find","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/longest_consecutive_sequence/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<p>Problem Link</p> <p>Brute Force: Since we only need to find the longest consecutive sequence irrespective of order in array, we can check the sequence starting each element and take the longest. This would result in \\(O(n^2)\\) time  complexity.</p> <p>To optimize this, we can just check the sequence for \\(num_i\\) whose previous number (\\(num_i-1\\)) isn't present in our  array, as these number are guaranteed to generate unique sequence . This would result in checking the sequence for elements only once. </p> Pseudocode <ul> <li>Iterate over the nums array. To keep checks constant time, we can also create a Hashset out of <code>nums</code> array.</li> <li>For each <code>num</code>, if the previous (<code>num-1</code>) isn't present in our array means we've a unique sequence starting    from this <code>num</code>.</li> <li>To generate this sequence, declare a length pointer and increment it until we exhaust the sequence numbers   present in our hashset.</li> <li>Finally use a global variable to maintain the maximum length.</li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), single iteration over each element with constant time checks. It might look like we're iterating within 2 loops, but the conditional will reduce the inner iteration such that we're not repeating checks.</p> <p>Space: \\(O(n)\\) &lt;- from hashmap.</p> PythonGo <pre><code>class Solution:\n    def longestConsecutive(self, nums: List[int]) -&gt; int:\n        res = 0\n        nums = set(nums)\n        for num in nums:\n            if num-1 not in nums:\n                length = 1\n                while num+length in nums:\n                    length+=1\n                res = max(length, res)\n        return res\n</code></pre> <pre><code>func longestConsecutive(nums []int) int {\n    set := make(map[int]interface{})\n    for _, num := range nums {\n        set[num] = nil\n    }\n    res := 0\n    for num, _ := range set {\n        if _, ok := set[num-1]; !ok {\n            length := 1\n            for {\n                if _, ok := set[num+length]; ok {\n                    length++\n                } else {\n                    break\n                }\n            }\n            res = max(res, length)\n        }\n    }\n    return res\n}\n</code></pre>","tags":["Array","Hash Table","Union Find","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/product_of_array_except_self/","title":"\ud83d\udfe0 238. Product of Array Except Self","text":"","tags":["Array","Prefix Sum","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/product_of_array_except_self/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<p>Problem Link</p> <p>The catch of problem is we can't use division operator. If that wasn't the case, we could simply have aggregated multiplication of whole array and divide each element by it get their own product without self.</p> <p>When translated to equations, this would look like: \\(\\prod_{i=1}^{n} nums_i \\over nums_i\\). By removing the division  -&gt; \\(\\prod_{i=1}^{i-1} nums_i * \\prod_{i=i+1}^{n} nums_i\\), which is basically product of prefix and postfix array to index <code>i</code>.</p> <p>One way to implement this is to store prefix and postfix multiplication in two separate arrays and combine them to generate the result. </p> <p>Follow Up</p> <p>Instead of saving the prefix and postfix multiplication within separate array, we can simply store them within output array (since multiplication is communicative) </p> Pseudocode <ul> <li>To generate prefix, iterate from start of <code>nums</code> and using a variable to aggregate the multiplication over   the iteration.</li> <li>To generate postfix, iterate from end of <code>nums</code> and repeat same.</li> </ul> Runtime Complexity <p>Time: \\(O(n)\\)</p> <p>Space: \\(O(1)\\) &lt;- output isn't considered</p> PythonGo <pre><code>class Solution:\n    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:\n        result = []\n        pre, post = 1, 1\n\n        for i in range(len(nums)):\n            result.append(pre)\n            pre *= nums[i]\n\n        for i in reversed(range(len(nums))):\n            result[i] *= post\n            post *= nums[i]\n        print(result)\n        return result\n</code></pre> <pre><code>func productExceptSelf(nums []int) []int {\n    result := make([]int, len(nums))\n    var pre, post int = 1, 1\n    for idx := range nums {\n        result[idx] = pre\n        pre *= nums[idx]\n    }\n\n    for idx := len(nums) - 1; idx &gt;= 0; idx-- {\n        result[idx] *= post\n        post *= nums[idx]\n    }\n    return result\n}\n</code></pre>","tags":["Array","Prefix Sum","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/top_k_frequent_element/","title":"\ud83d\udfe0 347. Top K Frequent Elements","text":"","tags":["Hash Table","Array","Heap/Priority Queue","LC_Medium","Neetcode150","Bucket Sort"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/top_k_frequent_element/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<p>Problem Link</p> <p>Heap</p> <p>This is a general problem designed to be solved efficiently using heap data structure. For now, we'll solve it using hashmaps.</p> <p>The general idea to solve this is by generating a hashmap where the value is list of numbers and key is the frequency of those number in <code>nums</code>. Now, you can use this hashmap to generate list of nums sorted in order of their frequency in <code>nums</code>. But for this problem, we only want first \\(k\\) elements from this list.</p> Pseudocode <ul> <li>Generate hashmap where key is \\(num\\) and value is frequency of that \\(num\\) in <code>nums</code>.</li> <li>Using above hashmap, generate another hashmap where key is a number and value is the list   of numbers having \\(key\\) frequency in <code>nums</code>.</li> <li>Generate result having numbers sorted in order of highest frequency.    Since the highest frequency could be <code>len(nums)</code> while smallest -&gt; \\(0\\).<ul> <li>Iterate from the highest frequency to the smallest while adding numbers of   frequencies found in our hashmap. </li> </ul> </li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), from iterating <code>nums</code>.</p> <p>Space: \\(O(n)\\) &lt;- from hashmaps.</p> PythonGo <pre><code>class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        freq = Counter(nums)\n        buckets = defaultdict(list)\n        for num, count in freq.items():\n            buckets[count].append(num)\n\n        result = []\n        for count in range(len(nums), 0, -1):\n            if count in buckets:\n                result.extend(buckets[count])\n\n        return result[:k]\n</code></pre> <pre><code>func topKFrequent(nums []int, k int) []int {\n    freq := make(map[int]int)\n    for _, num := range nums {\n        freq[num]++\n    }\n    buckets := make(map[int][]int)\n    for num, count := range freq {\n        buckets[count] = append(buckets[count], num)\n    }\n\n    var result []int\n    for i := len(nums); i &gt;= 0; i-- {\n        vals, ok := buckets[i]\n        if ok {\n            result = append(result, vals...)\n        }\n    }\n    return result[:k]\n}\n</code></pre>","tags":["Hash Table","Array","Heap/Priority Queue","LC_Medium","Neetcode150","Bucket Sort"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/two_sum/","title":"\ud83d\udfe2 1. Two Sum","text":"","tags":["Hash Table","Array","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/two_sum/#1-two-sum","title":"1. Two Sum","text":"<p>Problem Link</p> <p>You can think of the problem as,  given a number \\(num\\) find the index of \\(target-num\\).</p> <p>This can be done by storing the index of each \\(num\\) in a data structure like Hashmap which can be queried to fetch index of a value in a constant time.</p> Pseudocode <ul> <li>Iterate over the \\(nums\\) array. For each \\(num\\),</li> <li>check if the \\(target-num\\) is present in our map.<ul> <li>If yes, we can directly return the current index and saved index from here</li> <li>Else, store the index of current num in our map and continue. </li> </ul> </li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), since we're only iterating the nums array once and querying hashmap is an \\(O(1)\\) operation.</p> <p>Space: \\(O(n)\\), due to the map used for storing num -&gt; index mapping</p> PythonGo <pre><code>class Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        s = dict()\n        for i, num in enumerate(nums):\n            if num in s:\n                return [i, s[num]]\n            s[target - num] = i\n        return [-1, -1]\n</code></pre> <pre><code>func twoSum(nums []int, target int) []int {\n    idxMap := make(map[int]int)\n    for idx, num := range nums {\n        if val, ok := idxMap[num]; ok {\n            return []int{val, idx}\n        }\n        idxMap[target-num] = idx\n    }\n    return []int{}\n}\n</code></pre>","tags":["Hash Table","Array","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/valid_anagram/","title":"\ud83d\udfe2 242. Valid Anagram","text":"","tags":["Hash Table","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/valid_anagram/#242-valid-anagram","title":"242. Valid Anagram","text":"<p>Problem Link</p> <p>Given strings <code>s</code> and <code>t</code>, they're Anagram if we can rearrange the characters of one to form another. This can be reworded as, both strings should have same characters. We can check this by storing the frequency of one string and match them with the other.  </p> Pseudocode <ul> <li>If strings have different number of characters, we can return early as they'll never have same characters.</li> <li>Otherwise, we'll iterate over one string and store the frequency of each character in a hashmap.</li> <li>Iterate over other string to reduce the frequency of encountered character.</li> <li>During which, we can say the strings aren\u2019t anagrams if we encounter any character which either isn't present              in our hashmap, or the frequency of character is exhausted.</li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), since we're only iterating the strings twice, with insertion and querying hashmap being \\(O(1)\\)             operation.</p> <p>Space: \\(O(n)\\), due to the hashmap used for storing characters frequency.</p> PythonGo <pre><code>class Solution:\n    def isAnagram(self, s: str, t: str) -&gt; bool:\n        if len(s) != len(t):\n            return False\n\n        freq = dict()\n        for i in s:\n            freq[i] = freq.get(i, 0) + 1\n\n        for i in t:\n            if i not in freq or freq[i] == 0:\n                return False\n\n            freq[i] -= 1\n\n        return True\n</code></pre> <pre><code>func isAnagram(s string, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    freq := make(map[rune]int)\n    for _, ch := range s {\n        freq[ch]++\n    }\n\n    for _, ch := range t {\n        val, ok := freq[ch]\n        if !ok || val == 0 {\n            return false\n        }\n        freq[ch]--\n    }\n    return true\n}\n</code></pre>","tags":["Hash Table","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/valid_sudoku/","title":"\ud83d\udfe0 36. Valid Sudoku","text":"","tags":["Array","Hash Table","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Arrays_and_Hashing/valid_sudoku/#36-valid-sudoku","title":"36. Valid Sudoku","text":"<p>Problem Link</p> <p>To check if a sudo board is valid, you've to satisfy 3 types of criteria: - each row shouldn't have repeating digit. - each column shouldn't have repeating digit. - each box (3x3 here) shouldn't have a repeating digit.</p> <p>This can be checked pretty easily using hash maps (similar to contains_dupliacte).</p> How would you map cells within a box to same key? <p>\\(key=(floor(row/3))*3 + (floor(col/3))\\)</p> Pseudocode <ul> <li>Iterate over the board using two loops. Within each iteration, if the cell isn't <code>.</code></li> <li>check if the value is present in your hashmap buckets.<ul> <li>if present, we can say the sudoku is invalid and return.</li> <li>else add the values to respective hashmap key.</li> </ul> </li> </ul> Runtime Complexity <p>number of elements in board -&gt; n</p> <p>Time: \\(O(n)\\), single iteration over each element with constant time checks.</p> <p>Space: \\(O(n)\\) &lt;- from hashmaps.</p> PythonGo <pre><code>class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:\n        rows = defaultdict(set)\n        cols = defaultdict(set)\n        box = defaultdict(set)\n        for r in range(len(board)):\n            for c in range(len(board[0])):\n                cell = board[r][c]\n                b = (r // 3) * 3 + c // 3\n                if cell == \".\":\n                    continue\n                elif cell in rows[r] or cell in cols[c] or cell in box[b]:\n                    return False\n\n                rows[r].add(cell)\n                cols[c].add(cell)\n                box[b].add(cell)\n        return True\n</code></pre> <pre><code>func isValidSudoku(board [][]byte) bool {\n    var rows, cols, boxes [9][9]bool\n\n    for r := range board {\n        for c := range board[0] {\n            cell := board[r][c]\n            if cell != '.' {\n                b := (r/3)*3 + (c / 3)\n                idx := int(cell - '1')\n                if rows[r][idx] || cols[c][idx] || boxes[b][idx] {\n                    return false\n                }\n                rows[r][idx] = true\n                cols[c][idx] = true\n                boxes[b][idx] = true\n            }\n        }\n    }\n    return true\n}\n</code></pre>","tags":["Array","Hash Table","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Two_Pointers/3sum/","title":"\ud83d\udfe0 15. 3Sum","text":"","tags":["Two Pointers","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Two_Pointers/3sum/#15-3sum","title":"15. 3Sum","text":"<p>Problem Link</p> <p>This problem is similar to Two Sum, we can just use an outer iteration to reduce it to a two sum. But core part would be, how you'd avoid duplicate triplets in result?</p> <p>One approach could be by sorting the array, and since duplicate values would be adjacent we could directly skip them during each iteration. Also, Sorting Array is \\(O(nlogn)\\) operation, which wouldn't impact the runtime of our \\(O(n^2)\\) solution.  </p> Pseudocode <ul> <li>Sort the input Array and start an outer loop as an indicative of first number in triplet.</li> <li>Skip the number if it's same as previous number, as we've already solved for it and don't want duplicate.</li> <li>Within inner loop since the array is sorted, you can use similar approach as Two Sum 2.</li> </ul> Runtime Complexity <p>Time: \\(O(n^2)\\), from two loops.</p> <p>Space: \\(O(1)\\)/\\(O(n)\\), depending on sorting algorithm</p> PythonGo <pre><code>class Solution:\n    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:\n        result = []\n        nums.sort()\n        for i in range(len(nums)):\n            if i&gt;0 and nums[i] == nums[i-1]:\n                continue\n            j, k = i+1, len(nums)-1\n            while j &lt; k:\n                currSum = nums[i]+nums[j]+nums[k]\n                if currSum &gt; 0:\n                    k-=1\n                elif currSum &lt; 0:\n                    j+=1\n                else:\n                    result.append([nums[i], nums[j], nums[k]])\n                    j+=1\n                    while j &lt; k and nums[j] == nums[j-1]:\n                        j+=1\n        return result\n</code></pre> <pre><code>func threeSum(nums []int) [][]int {\n    sort.Ints(nums)\n    var result [][]int\n    for i := range nums {\n        if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] {\n            continue\n        }\n        j, k := i+1, len(nums)-1\n        for j &lt; k {\n            currSum := nums[i] + nums[j] + nums[k]\n            if currSum &gt; 0 {\n                k--\n            } else if currSum &lt; 0 {\n                j++\n            } else {\n                result = append(result, []int{nums[i], nums[j], nums[k]})\n                j++\n                for j &lt; k &amp;&amp; nums[j] == nums[j-1] {\n                    j++\n                }\n            }\n        }\n    }\n    return result\n}\n</code></pre>","tags":["Two Pointers","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Two_Pointers/container_with_most_water/","title":"\ud83d\udfe0 11. Container With Most Water","text":"","tags":["Two Pointers","Greedy","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Two_Pointers/container_with_most_water/#11-container-with-most-water","title":"11. Container With Most Water","text":"<p>Problem Link</p> <p>Area of container would be determined by two factors,  - width  - minimum height on either edges.</p> <p>We can use two pointers starting from the largest width available. To iterate over to next candidate, we can remove edges from either side. But we can greedily remove the shorter edge, as  this would be always the limiting factor in area calculation -&gt; \\((r-l)*min(height[l],height[r])\\). Also, the solution from shorter edges has been already considered in current iteration, so we don't have to worry about missing the current area in result.</p> Pseudocode <ul> <li>Iterate over the array using two pointers, left and right.</li> <li>During each iteration, calculate the area covered and update the global result if we've found larger value.</li> <li>Later we can just shift the left or right pointers to move onto next candidate to find global maxima.</li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), since we're only iterating the nums array once.</p> <p>Space: \\(O(1)\\), constant space from pointer variables.</p> PythonGo <pre><code>class Solution:\n    def maxArea(self, height: List[int]) -&gt; int:\n        result = 0\n        l, r = 0, len(height)-1\n        while l &lt; r:\n            curr = (r-l)*min(height[l], height[r])\n            result = max(result, curr)\n            if height[r] &gt; height[l]:\n                l+=1\n            else:\n                r-=1\n        return result\n</code></pre> <pre><code>func maxArea(height []int) int {\n    l, r := 0, len(height)-1\n    var result int\n    for l &lt; r {\n        curr := (r - l) * min(height[l], height[r])\n        result = max(result, curr)\n        if height[r] &gt; height[l] {\n            l++\n        } else {\n            r--\n        }\n    }\n    return result\n}\n</code></pre>","tags":["Two Pointers","Greedy","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Two_Pointers/trapping_rain_water/","title":"\ud83d\udd34 42. Trapping Rain Water","text":"","tags":["Two Pointers","LC_Hard","Neetcode150"]},{"location":"DSA/neetcode150/Two_Pointers/trapping_rain_water/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<p>Problem Link</p> <p>Think of the water amount as sum of water collected at each index. How would you calculate the trappable water at any index? This water level is bounded by the minimum of maximum heights on either side of given index.</p> <p></p> <p>With this, you can create such prefix arrays for maximum left and right heights of respective index and finally calculate the water trapped at each level. This would give us \\(O(n)\\) time and space complexity.</p> <p>We can optimize this to use \\(O(1)\\) space by using a two pointers technique. For this, we'll need to initialize two pointers at left and right ends, and two variables storing the maximum left and right heights of among iterated values. For example, with <code>l</code> and <code>r</code> index pointers,  lets say maxL &lt; maxR. For this, we can say for sure that the water collected for l cell is bounded by maxL. Because any consecutive height on right of <code>l</code> would be equal or greater than maxR which wouldn't impact our computation of water -&gt; \\(min(maxL, maxR)-height[i]\\).</p> Pseudocode <ul> <li>Declare two pointers for indicating current left and right position in iteration.</li> <li>Declare two variables to store the maximum left and right heights.</li> <li>Iterate over the array until we've computed water level for all cells i.e \\(l&lt;=r\\).</li> <li>For each iteration,<ul> <li>if \\(maxL &lt; maxR\\), we'll compute water level for <code>l</code> and increment the counter to next index</li> <li>else, we'll computer water level for <code>r</code> and decrement the counter to next index.</li> </ul> </li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), since we're only iterating the nums array once.</p> <p>Space: \\(O(1)\\), constant time from two pointers.</p> PythonGo <pre><code>class Solution:\n    def trap(self, height: List[int]) -&gt; int:\n        maxL, maxR = height[0], height[-1]\n        l, r = 0, len(height)-1\n        result = 0\n        while l &lt;= r:\n            if height[l] &lt; height[r]:\n                maxL = max(maxL, height[l])\n                result += maxL-height[l]\n                l+=1\n            else:\n                maxR = max(maxR, height[r])\n                result += maxR - height[r]\n                r-=1\n        return result\n</code></pre> <pre><code>func trap(height []int) int {\n    l, r := 0, len(height)-1\n    maxL, maxR := height[l], height[r]\n    var result int\n    for l &lt;= r {\n        if maxL &lt; maxR {\n            maxL = max(maxL, height[l])\n            result += maxL - height[l]\n            l++\n        } else {\n            maxR = max(maxR, height[r])\n            result += maxR - height[r]\n            r--\n        }\n    }\n    return result\n}\n</code></pre>","tags":["Two Pointers","LC_Hard","Neetcode150"]},{"location":"DSA/neetcode150/Two_Pointers/two_sum_2/","title":"\ud83d\udfe0 167. Two Sum II - Input Array Is Sorted","text":"","tags":["Two Pointers","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Two_Pointers/two_sum_2/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<p>Problem Link</p> <p>Similar to problem TwoSum, except the <code>nums</code> array is sorted now.  We can greedily use this information by comparing sum of left and right end. If our sum exceed target, we should reduce it by decreasing the right pointer. Else if our sum is smaller than target, we can increase our current sum by increasing left pointer.</p> Runtime Complexity <p>Time: \\(O(n)\\), since we're only iterating the nums array once.</p> <p>Space: \\(O(1)\\), constant space from two pointers.</p> PythonGo <pre><code>class Solution:\n    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:\n        l, r = 0, len(numbers)-1\n        while l &lt; r:\n            curr = numbers[l] + numbers[r]\n            if curr &gt; target:\n                r-=1\n            elif curr &lt; target:\n                l+=1\n            else:\n                return [l+1, r+1]\n        return [-1,-1]\n</code></pre> <pre><code>func twoSum2(numbers []int, target int) []int {\n    l, r := 0, len(numbers)-1\n    for l &lt; r {\n        curr := numbers[l] + numbers[r]\n        if curr &gt; target {\n            r--\n        } else if curr &lt; target {\n            l++\n        } else {\n            return []int{l + 1, r + 1}\n        }\n    }\n    return nil\n}\n</code></pre>","tags":["Two Pointers","LC_Medium","Neetcode150"]},{"location":"DSA/neetcode150/Two_Pointers/valid_palindrome/","title":"\ud83d\udfe2 125. Valid Palindrome","text":"","tags":["Two Pointers","LC_Easy","Neetcode150"]},{"location":"DSA/neetcode150/Two_Pointers/valid_palindrome/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<p>Problem Link</p> <p>Check Palindrome by comparing starting and ending characters in string. You can easily do this by  taking two pointers, pointing the respective position from start and end which should be same to form palindrome. </p> Pseudocode <ul> <li>Initialize start and end pointers</li> <li>Iterate over the string using the pointers until they meet or cross each other over bound.</li> </ul> Runtime Complexity <p>Time: \\(O(n)\\), single iteration over string.</p> <p>Space: \\(O(1)\\), constant space by two pointers.</p> PythonGo <pre><code>class Solution:\n    def isPalindrome(self, s: str) -&gt; bool:\n        l, r = 0, len(s)-1\n        while l &lt; r:\n            if not s[l].isalnum():\n                l+=1\n            elif not s[r].isalnum():\n                r-=1\n            elif s[l].lower() != s[r].lower():\n                return False\n            else:\n                l+=1\n                r-=1\n        return True\n</code></pre> <pre><code>func isPalindrome(s string) bool {\n    l, r := 0, len(s)-1\n    for l &lt; r {\n        for l &lt; r &amp;&amp; !unicode.IsDigit(rune(s[l])) &amp;&amp; !unicode.IsLetter(rune(s[l])) {\n            l++\n        }\n        for l &lt; r &amp;&amp; !unicode.IsDigit(rune(s[r])) &amp;&amp; !unicode.IsLetter(rune(s[r])) {\n            r--\n        }\n        if unicode.ToLower(rune(s[l])) != unicode.ToLower(rune(s[r])) {\n            return false\n        }\n        l++\n        r--\n    }\n    return true\n}\n</code></pre> Go Implementation note <p>Strings in Go are sequence of bytes , so when you access any particular index - it'll return the respective byte. While characters are represented using <code>rune</code> which represents a Unicode code point. Byte occupies 1 byte size while Rune can use upto 4 bytes size, which is why converting a byte using <code>rune(.)</code> isn\u2019t always safe. It's safe for ASCII characters which fall within 1 byte range.</p>","tags":["Two Pointers","LC_Easy","Neetcode150"]}]}